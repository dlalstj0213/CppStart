# C++ 기초(1)

## 키워드 (keyword)
- C++ 언어에서 **미리 용도를 정해 놓은** 단어
- 반드시 **정해진 용도**로만 사용
- **예약어**라고도 함

```C++
#include <iostream>
using namespace std;
int main()
{
    count << :"나의 첫 번째 C++ 프로그램" << endl;
    return 0;
}
/*
키워드 : using, namespace, int, return 
(main은 키워드가 아님, 그저 사용자 정의의 특수한 의미만 가지고 있음)
*/
```
## 식별자 (identifier)
- 여러 가지 대상을 **구분**하기 위해 만든 이름
  - 변수, 함수, 클래스 등의 이름
- 규칙
  - 첫 자는 비숫자 문자를 사용
  - 이후의 문자는 비숫자 문자와 숫자를 사용
  - 길이 제한 X
  - 일반적으로 특수문자는 포함 X
  - 키워드는 식별자로 사용 X
  - ex) (O) : abc, a3, myName (Camel case), MyName (Pascal case), initial_value, ...
  - ex) (X) : 4days, my name, my#name, int, initial-value, min:value, ... 

## 기본 자료형
- 정수 자료형: char, int, short, long, bool, ...
- 실수 자료형: float, double, long double, ...

## 복합 자료형
- 배열, 구조체(struct), 클래스(class), 열거형, 공용체
- 포인터, 참조

## 정수 자료형(integral types)
- 고정소수점(fixed-point) 방식의 숫자 표현
  - 오버플로가(overflow) 발생하지 않도록 주의
- 문자를 표현하는 자료형: char
- 정수를 표현하는 자료형: int, short, long, long long
  - signed / unsigned 정수와 음수를 표현
- 참/거짓을 표현하는 자료형
  - bool: true 또는 false를 저장

## 실수 자료형
- 부동소수점(floating-point) 방식의 숫자 표현
- float(4byte)
  - 부호 1bit, 지수부 8bit, 가수부 23bit로 구성
- double(8byte)
  - 부호 1bit, 지수부 11bit, 가수부 52bit로 구성

## 상수의 표현 - 리터럴(literal)
- **정수형 리터럴의 표현**
  - 숫자를 표현하는 문자와 부호만으로 표현됨
    - `0~9`
    - 16진수: `a~f`와 `A~F`
  - 접두사를 이용한 진법의 표현
    - `159` - 10진수 int형 상수
    - `0b10011111` - 2진수 int형 상수
    - `0237` - 8진수 int형 진수
    - `0x9f` - 16진수 int형 상수
  - 접미사를 이용한 정수 리터럴의 자료형 지정
    - `123` - int형
    - `123u` - unsigned int형
    - `123L` - long형
    - `123ul` - unsigned long형
    - `123ll` - long long형

- **문자 리터럴의 표현**
  - 작은 따옴표 (' ')안에 문자를 표기하는 방법
  - 8진수나 16진수 문자 코드로 표기하는 방법
  - `A` - 문자 'A'(ASCII 코드에 해당하는 정수 65와 동일)
  - `\101` - 'A'와 동일함 (65의 8진수 표현)
  - `\x41` - 'A'와 동일함 (65의 16진수 표현)

- **실수 리터럴의 표현**
  - 소수점이 있거나 10의 거듭제곱을 표현하기 위한 지수 기호인 'e'가 있으면 실수형 리터럴임
    - `1200.` = `1200.0` = `12e2` = `1.2e+3` = double형 값 1200
    - `1200.0f` = `12e2f` = float형 값 1200

## 변수
- 프로그램이 실행되는 동안 **기억**하고 있어야 하는 값들을 **저장**하는 **메모리 영역**
- 변수에는 이름이 지정되어야 함
- 모든 변수는 사용하기 전에 **미리 선언**해야 함
- 위치
  - 함수 **내부** -> **지역변수**
  - 함수 **외부** -> **전역변수**
- **변수 선언 형식**
  - 형식1: `int size;`
  - 형식2: `int size, price, stock;`
- **변수 초기화**
  - 형식1: `int total = 0;`
  - 형식2: `int total(0);`
    - <!>
  ```C++
   int x= 1.5; //1로 초기화
   float y(x); //1로 초기화
  ```
  - 형식3: `int total = {0};` ( C++11부터 형식3을 권장 ! )
    - <!>
  ```c++
  int toatl = {0};
  short x{total}; //오류: 축소 변환
  float y{total}; //오류: 축소 변환
  ```
- **자료형 추론**
  - 변수를 초기화할 때 초기화하는 값의 자료형으로 변수의 자료형을 추론함
  - ex) `auto i(10); // int i(10);과 동일함`

## const와 constexpr
- **const 한정어**
  - 변수의 값을 수정할 수 없게 함
  - 초기화를 통해서만 값을 정할 수 있음
  - ex) `const double PI {3.13157}; // 원주율 정의`
    - 비교) `#define PI 3.14159 // 매크로 상수 정의` (최근에는 define으로 상수로 정의하는 것은 **권장하지 않음**)

- **constexpr 한정어**
  - 그 값을 **컴파일할 때 평가**한다는 의미
  - 실행 중 값을 평가하는 것에 비해 **효율적**으로 동작할 수 있게 함
  ```c++
  int a;
  std::cin >> a;
  const int B = 20;
  const int C1 = a; //cin을 통해 입력된 a의 값으로 초기화
  constexpr int C2 = a + 10; // 오류: 컴파일 시에 a의 값을 알 수 없음
  constexpr int C3 = B + 100; // b+100을 컴파일 시에 계산할 수 있음
  constexpr int C4 = C1 * 2; // 오류: 컴파일 시에 C1의 값을 알 수 없음
  ```
- **constexpr 함수**
  - 모든 인수가 constexpr인 경우 컴파일할 때 값을 구할 수 있게 함
```C++
constexpr int fac(int n){
    return n > 1 ? n*f(n-1) : 1;
}
void f(int x){
    constexpr int a = fac(4); // 컴파일할 때 계산
    int b = fac(x); // 실행 중 계산
    ...
}
```
## 변수의 유효기간 (lifetime)
- 변수가 언제 만들어져서 언제 없어지는가를 나타냄
- **자동 변수**
  - 생성 시점: 함수(함수 안의 블록)가 시작될 때
  - 소멸 시점: 함수(함수 안의 블록)가 종료될 때
- **정적 변수**
  - 생성 시잠: 프로그램이 시작될 때
  - 소멸 시점: 프로그램이 종료될 때

```C++
int x; // 전역변수 - 정적 유효기간
int f(){
    int y; // 지역변수 - 자동 유효기간
    static int z; // 정적 지역변수 - 정적 유효기간
}
```
## 변수와 상수 사용 예
```C++
#include <iostream>
using namespace std;

int main(){
    const double PI { 3.14159 };
    double radius;
    cout << "원의 반경을 입력하시오 : ";
    cin >> radius;
    double area = radius * radius * PI;
    cout << "원의 면적 = " << area << endl;
    return 0;
}
```

## 연산자
- **2항 연산자**
  - 사칙 연산자: +, -, *, /
  - 나머지 연산자: % (수학적인 계산방식과 다름)
- **단항 연산자**
  - 증, 감 연산자: ++, -- ( 후치(후기 표기법):a++/전치(전이 표기법):++a )
  - 부호 연산자: +, -
- **대입 연산자 (=)**

  |수식<br>(수식의 값)|실행 결과<br>(저장된 결과)|
  |:---:|:---:|
  |a = 0| a <- 0|
  |a = b = 0 | b <- 0, a <- 0|
  |a = b = 1.5<br>(a는 double, b는 int일때) | b <- 1, a <-1 |
- **복합 대입 연산자**
  - 이항 연산자와 대입 연산자를 결합
  - +=, -=, *=, /=, %=, <<=, >>= 등
- **관계 연산자**
  - <, >, >=, <=, ==, !=
  - 수식의 값 => true / false
- **논리 연산자**
  - 논리 합 ||, 논리곱 &&, 부정 !
  - 수식의 값 => true / false
- **비트 단위 연산자**
  - 비트 단위 논리 연산자
    - 논리 합 |, 논리곱 &, 배타적 논리 합 ^, 부정 ~  
      |수식|수식의 값|
      |:---:|:---:|
      |x는 0x35(0011 0101)<br>y는 0xf0(1111 0000)일때||
      |`x | y`|0xf5 (**1111** 0101)|
      |`x & y`|0x30 (0011 **0000**)|
      |`x ^ y`|0xc5 (1100 0101)|
    |`~x`|0xca (1100 1010)|
  - 비트 이동 연산자
    - 좌측 이동 << : 우측 피연산자에 지정된 비트 수만큼 좌측 피연산자를 좌측으로 이동
      - 우측의 비는 비트에는 0이 채워짐
      - ex)
        ```C++
        unsigned char x = 0b00011101; //29
        unsigned char y = x << 2; //116
        ```
        |`x`|0|0|0|1|1|1|0|1|
        |--|--|--|--|--|--|--|--|--|

        |`y`|<del>0</del>|<del>0</del>|0|1|1|1|0|1|<mark>0</mark>|<mark>0</mark>|
        |--|--|--|--|--|--|--|--|--|--|--|  
    - 우측 이동 >> : 우측 피연산자에 지정된 비트 수만큼 좌측 피연산자를 우측으로 이동
      - singed형에 대해서는 부로를 유지할 수 있도록 부호와 같은 비트가 좌측의 비는 비트에 채워짐(구현에 따라 다름)
      - ex)
        ```c++
        char x = 0b10010100; //-108
        char y = x >> 2; //-27
        ```
        |`x`|1|0|0|1|0|1|0|0|
        |--|--|--|--|--|--|--|--|--|

        |`y`|<mark>1</mark>|<mark>1</mark>|1|0|0|1|0|1|<del>0</del>|<del>0</del>|
        |--|--|--|--|--|--|--|--|--|--|--|  
- **조건 연산자**
  - 유일한 3항 연산자
  - `조건 ? 값1: 값2`
    - -> 조건이 true이면 수식의 값은 값1, false이면 값2
    
    |수식|수식의 값|
    |:---:|:---:|
    |a는 10, b는 20, c는 30일때||
    |a > 0 ? b : c|20|

## 자료형의 변환
- **묵시적 형 변환**
  - 묵시적 형 변환 개요
    - 두 값 사이의 연산에서는 우선순위가 낮은 자료형의 값이 순위가 높은 자료혀으이 값과 같은 형으로 자동적으로 변환됨
    - 여러 개의 연산으로 구성된 수식에서 묵시적 형 변환은 **연산자 단위**로 이루어짐
    - **대입 연산자(=)는** 값을 저장할 변수의 자료형으로 묵시적 형 변환을 함
      - 오차나 오버플로가 발생할 수 있으므로 주의해야함
- **명시적 형 변환**
  - `static_cast`: 실행 중에 형 검사를 하지 않으며, 컴파일 할 때 수식에 지정된 그대로 변환함
  - `dynamic_cast`: 기초 클래스와 파생 클래스 간의 포인터 또는 참조 형 변환이 프로그램 실행 중에 일어나도록 지시함
  - `reinterpret_cast`: 포인터를 다른 자료형의 포인터나 정수 자료형으로, 또는 그 역으로 변환함
  - `const_cast`: const 지정을 일시 해제함